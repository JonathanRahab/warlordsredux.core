<!DOCTYPE html>
<html lang="en">

<head>
    <style>
        :root {
            --scale: 1;
            --ribbon-scale: 1;
            --anchor-x: 50vw;
            --anchor-y: 15vh;
            --gap: calc(12px * var(--scale));
            --points-slot: calc(12ch * var(--scale));
            --icons-max-width: calc(20vw * var(--scale));
            --badges-max-width: calc(40vw * var(--scale));
            --icons-feather: calc(30px * var(--scale));
        }

        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            color: #fff;
            overflow: hidden;
        }

        .stage {
            position: fixed;
            left: 0;
            right: 0;
            bottom: var(--anchor-y);
            height: calc(70px * var(--scale));
            pointer-events: none;
            overflow: visible;
        }

        .kf-left {
            position: absolute;
            left: 0;
            bottom: 0;
            width: calc(var(--anchor-x) - var(--gap));
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: calc(4px * var(--scale));
            white-space: nowrap;
            overflow: hidden;
            font-weight: bold;
            font-size: calc(16px * var(--scale));
            z-index: 2;
        }

        .kf-icons-viewport {
            position: relative;
            max-width: var(--icons-max-width);
            width: var(--icons-max-width);
            overflow: hidden;
            mask-image: linear-gradient(to right,
                    rgba(0, 0, 0, 0) 0,
                    rgba(0, 0, 0, 1) var(--icons-feather),
                    rgba(0, 0, 0, 1) 100%);
        }

        .kf-badges-viewport {
            position: relative;
            max-width: var(--badges-max-width);
            width: var(--badges-max-width);
            overflow: hidden;
            mask-image: linear-gradient(to right,
                    rgba(0, 0, 0, 0) 0,
                    rgba(0, 0, 0, 1) var(--icons-feather),
                    rgba(0, 0, 0, 1) 100%);
        }

        .kf-icons-row {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            gap: calc(8px * var(--scale));
            flex-wrap: nowrap;
        }

        .kf-badges-row {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            gap: calc(8px * var(--scale));
        }

        .kf-badge {
            border: calc(2px * var(--scale)) solid #00e1ff;
            border-radius: calc(6px * var(--scale));
            padding: calc(6px * var(--scale)) calc(10px * var(--scale));
            background: rgba(0, 0, 0, 0.6);
            display: inline-flex;
            align-items: center;
            transform-origin: right center;
            gap: calc(8px * var(--scale));
            font-size: calc(16px * var(--scale));
        }

        .kf-points {
            position: absolute;
            left: calc(var(--anchor-x) + var(--gap));
            top: 0;
            width: var(--points-slot);
            text-align: left;
            font-size: calc(28px * var(--scale));
            font-weight: 900;
            color: #fff;
            font-variant-numeric: tabular-nums;
            transform-origin: left center;
            z-index: 1;
        }

        .kf-left.unclipped,
        .kf-icons-row.unclipped,
        .kf-badges-row.unclipped {
            overflow: visible;
        }

        .kf-icon {
            height: calc(32px * var(--scale));
            width: auto;
            flex: 0 0 auto;
            display: block;
            object-fit: contain;
            pointer-events: none;
        }

        .kf-mult {
            opacity: 0.9;
        }

        .enter {
            animation: fadeIn calc(0.3s * var(--scale)) ease forwards;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateX(calc(-20px * var(--scale))) scale(0.98);
            }

            60% {
                opacity: 1;
                transform: translateX(0) scale(1.04);
            }

            to {
                opacity: 1;
                transform: translateX(0) scale(1);
            }
        }

        .exit {
            animation: fadeOut calc(0.5s * var(--scale)) ease forwards;
        }

        @keyframes fadeOut {
            to {
                opacity: 0;
                transform: translateX(calc(-30px * var(--scale)));
            }
        }

        .merge {
            animation: bump calc(260ms * var(--scale)) cubic-bezier(.2, .9, .2, 1.2) both;
        }

        @keyframes bump {
            0% {
                transform: translateX(0) scale(1);
                box-shadow: 0 0 0 0 rgba(0, 225, 255, 0);
            }

            25% {
                transform: translateX(0) scale(1.08);
                box-shadow: 0 0 calc(16px * var(--scale)) calc(4px * var(--scale)) rgba(0, 225, 255, .35);
            }

            100% {
                transform: translateX(0) scale(1);
                box-shadow: 0 0 0 0 rgba(0, 225, 255, 0);
            }
        }

        .points-merge {
            animation: pointsBump calc(280ms * var(--scale)) cubic-bezier(.2, .9, .2, 1.2) both;
        }

        @keyframes pointsBump {
            0% {
                transform: translateX(0) scale(1);
                text-shadow: 0 0 0 rgba(255, 255, 255, 0);
            }

            25% {
                transform: translateX(0) scale(1.1);
                text-shadow: 0 0 calc(14px * var(--scale)) rgba(255, 255, 255, .75);
            }

            100% {
                transform: translateX(0) scale(1);
                text-shadow: 0 0 0 rgba(255, 255, 255, 0);
            }
        }

        .kf-ribbons {
            position: fixed;
            left: 0;
            right: 0;
            top: 5vh;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            gap: calc(10px * var(--ribbon-scale));
            pointer-events: none;
            z-index: 30;
        }

        .kf-ribbon {
            pointer-events: none;
            position: relative;
            display: inline-flex;
            align-items: center;
            gap: calc(15px * var(--ribbon-scale));
            padding: calc(18px * var(--ribbon-scale)) calc(28px * var(--ribbon-scale));
            border-radius: calc(10px * var(--ribbon-scale));
            font-weight: 800;
            font-size: calc(38px * var(--ribbon-scale));
            letter-spacing: .25px;
            transform-origin: center bottom;
            opacity: 1;
            overflow: hidden;
        }

        .kf-ribbon::before {
            content: "";
            position: absolute;
            left: 6%;
            right: 6%;
            top: calc(4px * var(--ribbon-scale));
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, .65), transparent);
            opacity: .7;
            pointer-events: none;
        }

        .kf-ribbon::after {
            content: "";
            position: absolute;
            inset: 0;
            background:
                linear-gradient(75deg,
                    transparent 45%,
                    rgba(255, 255, 255, .20) 50%,
                    transparent 55%);
            transform: translateX(-120%);
            animation: ribbonSheen 2s ease-out 0.35s infinite;
            pointer-events: none;
        }

        @keyframes ribbonSheen {
            0% {
                transform: translateX(-120%);
                opacity: 0;
            }

            20% {
                opacity: 1;
            }

            100% {
                transform: translateX(120%);
                opacity: 0;
            }
        }

        .ribbon-level-1 {
            background-color: rgba(119, 158, 203, .65);
            border: calc(2px * var(--scale)) solid rgba(119, 158, 203, .9);
            box-shadow:
                0 0 calc(24px * var(--ribbon-scale)) rgba(119, 158, 203, .35),
                inset 0 0 0 calc(1px * var(--ribbon-scale)) rgba(119, 158, 203, .25);
        }

        .ribbon-level-2 {
            background-color: rgba(204, 117, 115, .65);
            border: calc(2px * var(--scale)) solid rgba(204, 117, 115, .95);
            box-shadow:
                0 0 calc(24px * var(--ribbon-scale)) rgba(204, 117, 115, .38),
                inset 0 0 0 calc(1px * var(--ribbon-scale)) rgba(204, 117, 115, .25);
        }

        .ribbon-level-3 {
            background-color: rgba(255, 215, 0, .65);
            border: calc(2px * var(--scale)) solid rgba(255, 215, 0, .95);
            box-shadow:
                0 0 calc(24px * var(--ribbon-scale)) rgba(255, 215, 0, .40),
                inset 0 0 0 calc(1px * var(--ribbon-scale)) rgba(255, 215, 0, .30);
        }

        .ribbon-icon {
            width: calc(64px * var(--scale));
            height: calc(64px * var(--scale));
            flex: 0 0 calc(64px * var(--scale));
            mask-repeat: no-repeat;
            mask-position: center;
            mask-size: contain;
            filter: drop-shadow(0 0 calc(6px * var(--ribbon-scale)) rgba(255, 255, 255, .25));
        }

        .ribbon-icon-level-1 {
            filter: drop-shadow(0 0 0 rgba(119, 158, 203, .55));
            background-color: #779ECB;
        }

        .ribbon-icon-level-2 {
            filter: drop-shadow(0 0 0 rgba(204, 117, 115, .55));
            background-color: #cc7573;
        }

        .ribbon-icon-level-3 {
            filter: drop-shadow(0 0 0 rgba(255, 215, 0, .55));
            background-color: #FFD700;
        }

        .ribbon-enter {
            animation: ribbonIn 320ms cubic-bezier(.22, .95, .18, 1.05) forwards;
        }

        @keyframes ribbonIn {
            from {
                opacity: 0;
                transform: translateX(-1000px);
            }

            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .ribbon-exit {
            animation: ribbonOut calc(260ms * var(--scale)) cubic-bezier(.2, .7, .3, 1) forwards;
        }

        @keyframes ribbonOut {
            to {
                opacity: 0;
                transform: translateX(1000px);
            }
        }

        .kf-ribbon[data-index] {
            animation-delay: calc(40ms * var(--scale) * var(--data-index, 0));
        }
    </style>
</head>

<body>
    <div class="stage">
        <div class="kf-left" id="kf-left">
            <div class="kf-icons-viewport">
                <div class="kf-icons-row" id="kf-icons-row"></div>
            </div>
            <div class="kf-badges-viewport">
                <div class="kf-badges-row" id="kf-badges-row"></div>
            </div>
        </div>
        <div class="kf-ribbons" id="kf-ribbons"></div>
        <span class="kf-points" id="kf-points"></span>
    </div>

    <script>
        document.imageCache = {};

        let KILLFEED_TIMEOUT_MS = 10000;
        let MIN_GAP_MS = 500;
        let RIBBON_MIN_SHOW_MS = 5000;

        const killfeedQueue = [];
        let isProcessingQueue = false;
        let lastAddTimestamp = 0;
        let totalPoints = 0;
        let displayedPoints = 0;

        function formatPoints(n) {
            try { return new Intl.NumberFormat().format(n); }
            catch { return String(n); }
        }

        const activeRafHandles = new WeakMap();

        function animatePoints(el, from, to) {
            const startValue = Number(from) || 0;
            const endValue = Number(to) || 0;

            const previousHandle = activeRafHandles.get(el);
            if (previousHandle !== undefined) cancelAnimationFrame(previousHandle);

            if (startValue === endValue) {
                displayedPoints = endValue;
                el.textContent = endValue > 0 ? formatPoints(endValue) : "";
                activeRafHandles.delete(el);
                return;
            }

            const delta = Math.abs(endValue - startValue);
            const durationMs = Math.min(500, 600 + Math.log10(delta + 1) * 650);

            const startTime = performance.now();
            const easeOutQuint = t => 1 - Math.pow(1 - t, 5);

            function animatePointStep(now) {
                const elapsed = now - startTime;
                const t = Math.min(1, elapsed / durationMs);
                const eased = easeOutQuint(t);
                const currentValue = Math.round(startValue + (endValue - startValue) * eased);

                if (currentValue !== displayedPoints) {
                    displayedPoints = currentValue;
                    el.textContent = currentValue > 0 ? formatPoints(currentValue) : "";
                }

                if (t < 1) {
                    const handle = requestAnimationFrame(animatePointStep);
                    activeRafHandles.set(el, handle);
                } else {
                    activeRafHandles.delete(el);
                }
            }

            const handle = requestAnimationFrame(animatePointStep);
            activeRafHandles.set(el, handle);
        }

        function addKillfeed(displayText, points, customColor, iconUrl) {
            killfeedQueue.push([displayText, points, customColor, iconUrl]);
            processQueue();
        }

        function processQueue() {
            if (isProcessingQueue) return;
            isProcessingQueue = true;

            const step = () => {
                if (killfeedQueue.length === 0) { isProcessingQueue = false; return; }

                const now = Date.now();
                const waitTime = Math.max(0, MIN_GAP_MS - (now - lastAddTimestamp));

                setTimeout(() => {
                    const [displayText, points, customColor, iconUrl] = killfeedQueue.shift();
                    addKillfeedImmediate(displayText, points, customColor, iconUrl);
                    lastAddTimestamp = Date.now();
                    step();
                }, waitTime);
            };

            step();
        }

        const activeAnimations = new WeakMap();
        function flipReorder(containerElement, elementToMove) {
            const ANIMATION_DURATION_MS = 200;
            const ANIMATION_EASING = 'cubic-bezier(0.2, 0.9, 0.2, 1.0)';

            const initialRects = new Map();
            const childrenBefore = Array.from(containerElement.children);

            for (const element of childrenBefore) {
                initialRects.set(element, element.getBoundingClientRect());

                const prev = activeAnimations.get(element);
                if (prev) {
                    try { prev.cancel(); } catch { }
                    activeAnimations.delete(element);
                }
            }

            containerElement.appendChild(elementToMove);

            const childrenAfter = Array.from(containerElement.children);
            const finishedPromises = [];

            containerElement.classList.add('unclipped');

            for (const element of childrenAfter) {
                const fromRect = initialRects.get(element);
                if (!fromRect) continue;

                const toRect = element.getBoundingClientRect();
                const deltaX = fromRect.left - toRect.left;
                const deltaY = fromRect.top - toRect.top;

                if (deltaX === 0 && deltaY === 0) continue;

                const animation = element.animate(
                    [{ transform: `translate(${deltaX}px, ${deltaY}px)` }, { transform: 'translate(0, 0)' }],
                    { duration: ANIMATION_DURATION_MS, easing: ANIMATION_EASING, fill: 'both' }
                );

                activeAnimations.set(element, animation);

                const settled = animation.finished
                    .catch(() => { })
                    .then(() => {
                        try { animation.cancel(); } catch { }
                        element.style.transform = '';
                        activeAnimations.delete(element);
                    });

                finishedPromises.push(settled);
            }

            Promise.allSettled(finishedPromises).then(() => {
                containerElement.classList.remove('unclipped');
            });
        }

        function injectImage(img, iconUrl) {
            if (document.imageCache[iconUrl]) {
                img.src = document.imageCache[iconUrl];
                return;
            }
            A3API.RequestTexture(iconUrl, 64).then(imageContent => {
                img.src = imageContent;
                document.imageCache[iconUrl] = imageContent;
            });
        }

        function addIconIndependent(iconUrl) {
            if (!iconUrl) return;
            const iconsRow = document.getElementById("kf-icons-row");

            const iconEl = document.createElement("img");
            iconEl.className = "kf-icon enter";
            injectImage(iconEl, iconUrl);
            iconsRow.appendChild(iconEl);

            iconEl._timeout = setTimeout(() => {
                iconEl.classList.remove("enter");
                iconEl.classList.add("exit");
                iconEl.addEventListener("animationend", () => iconEl.remove(), { once: true });
            }, KILLFEED_TIMEOUT_MS);
        }

        function addKillfeedImmediate(displayText, points, customColor, iconUrl) {
            A3API.SendAlert("A");

            const badgesRow = document.getElementById("kf-badges-row");
            const pointsBox = document.getElementById("kf-points");
            const pulse = (el, cls) => { if (!el) return; el.classList.remove(cls); void el.offsetWidth; el.classList.add(cls); };

            addIconIndependent(iconUrl);

            let badge = Array.from(badgesRow.querySelectorAll(".kf-badge"))
                .find(b => b.dataset.label === displayText && b.dataset.customColor === (customColor || ""));

            const incomingPoints = points | 0;

            if (badge) {
                const labelEl = badge.querySelector(".kf-label");
                let multEl = badge.querySelector(".kf-mult");

                const newCount = (parseInt(badge.dataset.count || "1", 10) + 1);
                badge.dataset.count = String(newCount);

                const newPoints = (parseInt(badge.dataset.points || "0", 10) + incomingPoints);
                badge.dataset.points = String(newPoints);

                if (labelEl) labelEl.textContent = displayText;

                if (newCount > 1) {
                    if (!multEl) {
                        multEl = document.createElement("span");
                        multEl.className = "kf-mult";
                        badge.appendChild(multEl);
                    }
                    multEl.innerHTML = `&times; ${newCount}`;
                } else if (multEl) {
                    multEl.remove();
                }

                flipReorder(badgesRow, badge);

                const target = totalPoints + incomingPoints;
                animatePoints(pointsBox, displayedPoints, target);
                totalPoints = target;

                pulse(badge, "merge");
                pulse(pointsBox, "points-merge");

                clearTimeout(badge._timeout);
                badge._timeout = setTimeout(() => removeBadge(badge), KILLFEED_TIMEOUT_MS);
                return;
            }

            const newBadge = document.createElement("span");
            newBadge.className = "kf-badge enter";
            newBadge.dataset.label = displayText;
            newBadge.dataset.count = "1";
            newBadge.dataset.points = String(incomingPoints);
            newBadge.dataset.customColor = customColor || "";

            const labelSpan = document.createElement("span");
            labelSpan.className = "kf-label";
            labelSpan.textContent = displayText;
            newBadge.appendChild(labelSpan);

            if (customColor) {
                newBadge.style.borderColor = customColor;
                newBadge.style.color = customColor;
            }

            badgesRow.appendChild(newBadge);

            const target = totalPoints + incomingPoints;
            animatePoints(pointsBox, displayedPoints, target);
            totalPoints = target;
            pulse(pointsBox, "points-merge");

            newBadge._timeout = setTimeout(() => removeBadge(newBadge), KILLFEED_TIMEOUT_MS);
        }

        function renderTotalPoints(pointsBox) {
            animatePoints(pointsBox, displayedPoints, totalPoints);
        }

        function removeBadge(badge) {
            const badgesRow = document.getElementById("kf-badges-row");
            const pointsBox = document.getElementById("kf-points");

            if (!badge || !badge.isConnected) return;

            badge.classList.remove("enter", "merge");
            badge.classList.add("exit");
            badge.addEventListener("animationend", () => {
                badge.remove();
                if (badgesRow.querySelectorAll(".kf-badge").length === 0) {
                    totalPoints = 0;
                    renderTotalPoints(pointsBox);
                }
            }, { once: true });
        }

        const ribbonQueue = [];
        let ribbonShowing = false;

        function addBadge(badgeName, iconUrl, badgeLevel) {
            ribbonQueue.push({ badgeName: String(badgeName || ""), iconUrl: iconUrl || "", badgeLevel: badgeLevel || "" });
            processRibbonQueue();
        }

        function processRibbonQueue() {
            if (ribbonShowing) return;
            const next = ribbonQueue.shift();
            if (!next) return;

            ribbonShowing = true;
            showRibbon(next).finally(() => {
                ribbonShowing = false;
                processRibbonQueue();
            });
        }

        function showRibbon({ badgeName, iconUrl, badgeLevel }) {
            return new Promise((resolve) => {
                if (badgeLevel === 3) {
                    A3API.SendAlert("C");
                } else {
                    A3API.SendAlert("B");
                }

                const mount = document.getElementById("kf-ribbons");

                const ribbon = document.createElement("div");
                ribbon.className = "kf-ribbon ribbon-enter";

                if (badgeLevel === 1) {
                    ribbon.classList.add("ribbon-level-1");
                } else if (badgeLevel === 2) {
                    ribbon.classList.add("ribbon-level-2");
                } else {
                    ribbon.classList.add("ribbon-level-3");
                }

                const icon = document.createElement("div");
                icon.className = "ribbon-icon";

                if (badgeLevel === 1) {
                    icon.classList.add("ribbon-icon-level-1");
                } else if (badgeLevel === 2) {
                    icon.classList.add("ribbon-icon-level-2");
                } else {
                    icon.classList.add("ribbon-icon-level-3");
                }

                if (iconUrl) {
                    const cached = document.imageCache[iconUrl];
                    if (cached) {
                        applyMask(icon, cached);
                    } else {
                        A3API.RequestTexture(iconUrl, 64).then(imageContent => {
                            document.imageCache[iconUrl] = imageContent;
                            applyMask(icon, imageContent);
                        }).catch(() => { /* fail silently */ });
                    }
                }

                const label = document.createElement("span");
                label.textContent = badgeName || "";

                ribbon.appendChild(icon);
                ribbon.appendChild(label);
                mount.replaceChildren(ribbon);

                const minTimer = setTimeout(() => {
                    ribbon.classList.remove("ribbon-enter");
                    ribbon.classList.add("ribbon-exit");
                    ribbon.addEventListener("animationend", () => {
                        ribbon.remove();
                        resolve();
                    }, { once: true });
                }, RIBBON_MIN_SHOW_MS);

                ribbon.addEventListener("DOMNodeRemoved", () => {
                    clearTimeout(minTimer);
                    resolve();
                }, { once: true });
            });
        }

        function applyMask(el, dataUrl) {
            el.style.maskImage = `url("${dataUrl}")`;
        }

        function setSettings(scale, ribbonScale, feedTimeout, minGap, ribbonMinShow, anchorX, anchorY) {
            document.documentElement.style.setProperty('--scale', scale);
            document.documentElement.style.setProperty('--ribbon-scale', ribbonScale);

            document.documentElement.style.setProperty('--anchor-x', `${anchorX}vw`);
            document.documentElement.style.setProperty('--anchor-y', `${anchorY}vh`);

            KILLFEED_TIMEOUT_MS = feedTimeout;
            MIN_GAP_MS = minGap;
            RIBBON_MIN_SHOW_MS = ribbonMinShow;
        }

        // addBadge("AIR DEFENSE SUPPRESSION", "A3\\ui_f\\data\\map\\markers\\military\\pickup_CA.paa", 1);
        // addBadge("JUST ONE MORE ROCKET", "A3\\ui_f\\data\\map\\markers\\military\\pickup_CA.paa", 2);
        // addBadge("ACE PILOT", "A3\\ui_f\\data\\map\\markers\\military\\pickup_CA.paa", 3);
        // addBadge("HEAVY METAL", "A3\\ui_f\\data\\map\\markers\\military\\pickup_CA.paa", 3);
        // addBadge("SIZE MATTERS NOT", "A3\\ui_f\\data\\map\\markers\\military\\pickup_CA.paa", 2);
    </script>
</body>

</html>